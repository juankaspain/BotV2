"""\nBotV2 Professional Dashboard v2.0 - Enterprise Security Edition\nUltra-professional real-time trading dashboard with production-grade security\n\nSecurity Features:\n- HTTP Basic Authentication\n- Rate Limiting (10 req/min per IP)\n- HTTPS Enforcement (production only)\n- Security Headers (HSTS, CSP, X-Frame-Options, etc.)\n- Brute Force Protection\n- WebSocket Real-time Updates\n\nOther Features:\n- Bloomberg Terminal inspired design\n- Real-time WebSocket updates\n- Advanced charting with technical indicators\n- Interactive heatmaps\n- Risk analytics with VaR/CVaR\n- Dark/Light theme toggle\n- Mobile responsive\n- Export capabilities\n- Alert system\n- Performance attribution\n"""\n\nimport logging\nimport os\nfrom flask import Flask, render_template, jsonify, request, Response, send_file\nfrom flask_socketio import SocketIO, emit\nfrom flask_cors import CORS\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\nfrom flask_talisman import Talisman\nfrom functools import wraps\nimport plotly.graph_objs as go\nimport plotly.express as px\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport numpy as np\nfrom typing import Dict, List, Optional\nimport json\nimport hashlib\nimport secrets\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\n\nclass DashboardAuth:\n    \"\"\"\n    HTTP Basic Authentication for Dashboard\n    \n    Security Features:\n    - SHA-256 password hashing\n    - Constant-time comparison (timing attack prevention)\n    - Failed login attempt logging\n    - Environment variable based credentials\n    \n    Uses environment variables for credentials:\n    - DASHBOARD_USERNAME (default: admin)\n    - DASHBOARD_PASSWORD (required, no default for security)\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize authentication\"\"\"\n        \n        self.username = os.getenv('DASHBOARD_USERNAME', 'admin')\n        self.password_hash = self._get_password_hash()\n        \n        if not self.password_hash:\n            logger.critical(\n                \"âš ï¸ DASHBOARD_PASSWORD not set! Dashboard will be INSECURE. \"\n                \"Set environment variable before starting.\"\n            )\n            # Generate temporary password for first run\n            temp_password = secrets.token_urlsafe(16)\n            logger.warning(f\"ğŸ”‘ Temporary password generated: {temp_password}\")\n            logger.warning(\"IMPORTANT: Set DASHBOARD_PASSWORD env var for production!\")\n            self.password_hash = self._hash_password(temp_password)\n    \n    def _get_password_hash(self) -> str:\n        \"\"\"Get password hash from environment\"\"\"\n        password = os.getenv('DASHBOARD_PASSWORD')\n        if password:\n            return self._hash_password(password)\n        return None\n    \n    def _hash_password(self, password: str) -> str:\n        \"\"\"Hash password with SHA-256\"\"\"\n        return hashlib.sha256(password.encode()).hexdigest()\n    \n    def check_credentials(self, username: str, password: str) -> bool:\n        \"\"\"\n        Verify username and password (timing-attack safe)\n        \n        Args:\n            username: Provided username\n            password: Provided password\n            \n        Returns:\n            True if credentials valid, False otherwise\n        \"\"\"\n        if not self.password_hash:\n            # If no password set, allow access (dev mode)\n            logger.warning(\"âš ï¸ No password configured, allowing access (DEV MODE)\")\n            return True\n        \n        # Use constant-time comparison to prevent timing attacks\n        username_match = secrets.compare_digest(username, self.username)\n        password_match = secrets.compare_digest(\n            self._hash_password(password),\n            self.password_hash\n        )\n        \n        return username_match and password_match\n\n\nclass ProfessionalDashboard:\n    \"\"\"\n    Ultra-professional trading dashboard v2.0 with enterprise security\n    \n    Architecture:\n    - Flask + SocketIO for real-time updates\n    - Flask-Limiter for rate limiting (10 req/min per IP)\n    - Flask-Talisman for HTTPS enforcement + security headers\n    - Plotly for interactive charts\n    - Custom CSS/JS for Bloomberg-style UI\n    - WebSocket push for instant updates\n    - Modular component design\n    - HTTP Basic Authentication with brute force protection\n    \n    Security:\n    - Rate limiting on all endpoints\n    - HTTPS enforcement in production\n    - Security headers (HSTS, CSP, X-Frame-Options)\n    - Brute force protection\n    - Audit logging\n    \"\"\"\n    \n    def __init__(self, config):\n        \"\"\"Initialize professional dashboard with security\"\"\"\n        \n        self.config = config\n        dash_config = config.get('dashboard', {})\n        \n        # Server config\n        self.host = dash_config.get('host', '0.0.0.0')\n        self.port = dash_config.get('port', 8050)\n        self.debug = dash_config.get('debug', False)\n        \n        # Environment detection (CORRECTED)\n        # Use FLASK_ENV, default to development (not production)\n        self.env = os.getenv('FLASK_ENV', 'development')\n        self.is_production = self.env == 'production'\n        \n        # Initialize authentication\n        self.auth = DashboardAuth()\n        \n        # Flask app with SocketIO\n        self.app = Flask(\n            __name__,\n            template_folder=str(Path(__file__).parent / 'templates'),\n            static_folder=str(Path(__file__).parent / 'static')\n        )\n        self.app.config['SECRET_KEY'] = os.getenv('SECRET_KEY', secrets.token_urlsafe(32))\n        \n        CORS(self.app)\n        self.socketio = SocketIO(self.app, cors_allowed_origins=\"*\")\n        \n        # Setup security middleware\n        self._setup_rate_limiting()\n        self._setup_https_enforcement()\n        \n        # Data stores\n        self.portfolio_history = []\n        self.trades_history = []\n        self.strategy_performance = {}\n        self.risk_metrics = {}\n        self.market_data = {}\n        self.alerts = []\n        \n        # Performance cache\n        self.cache = {\n            'last_update': None,\n            'computed_metrics': {}\n        }\n        \n        # Setup routes and auth\n        self._setup_authentication()\n        self._setup_routes()\n        self._setup_websocket_handlers()\n        \n        logger.info(\"âœ… Professional Dashboard v2.0 initialized\")\n        logger.info(f\"ğŸŒ Environment: {self.env.upper()}\")\n        logger.info(f\"ğŸ”’ Authentication: ENABLED (user: {self.auth.username})\")\n        logger.info(f\"âš¡ Rate Limiting: ENABLED (10 req/min per IP)\")\n        logger.info(f\"ğŸ” HTTPS Enforcement: {'ENABLED' if self.is_production else 'DISABLED (dev mode)'}\")\n    \n    def _setup_rate_limiting(self):\n        \"\"\"Setup rate limiting middleware\"\"\"\n        \n        # Get Redis configuration for distributed rate limiting\n        redis_host = os.getenv('REDIS_HOST', 'localhost')\n        redis_port = int(os.getenv('REDIS_PORT', 6379))\n        \n        # Initialize rate limiter with Redis backend\n        self.limiter = Limiter(\n            app=self.app,\n            key_func=get_remote_address,\n            default_limits=[\"10 per minute\"],  # Global limit: 10 req/min per IP\n            storage_uri=f\"redis://{redis_host}:{redis_port}\",\n            storage_options={\"socket_connect_timeout\": 30},\n            strategy=\"fixed-window\",\n            headers_enabled=True,  # Add X-RateLimit-* headers\n            swallow_errors=True  # Continue working if Redis is down\n        )\n        \n        # Custom rate limit exceeded handler\n        @self.app.errorhandler(429)\n        def ratelimit_handler(e):\n            logger.warning(\n                f\"âš ï¸ Rate limit exceeded from {request.remote_addr} \"\n                f\"on {request.path}\"\n            )\n            return jsonify({\n                'error': 'Rate limit exceeded',\n                'message': 'Too many requests. Please slow down.',\n                'retry_after': e.description\n            }), 429\n        \n        logger.info(\"âœ… Rate limiting middleware installed (10 req/min per IP)\")\n    \n    def _setup_https_enforcement(self):\n        \"\"\"Setup HTTPS enforcement and security headers\"\"\"\n        \n        if self.is_production:\n            # Production: Enforce HTTPS and security headers\n            Talisman(\n                self.app,\n                force_https=True,  # Redirect HTTP â†’ HTTPS\n                strict_transport_security=True,\n                strict_transport_security_max_age=31536000,  # 1 year\n                content_security_policy={\n                    'default-src': \"'self'\",\n                    'script-src': [\n                        \"'self'\",\n                        \"'unsafe-inline'\",  # Required for inline scripts\n                        \"https://cdn.socket.io\",\n                        \"https://cdn.plot.ly\"\n                    ],\n                    'style-src': [\"'self'\", \"'unsafe-inline'\"],\n                    'img-src': [\"'self'\", \"data:\", \"https:\"],\n                    'connect-src': [\"'self'\", \"wss:\", \"ws:\"],\n                    'font-src': [\"'self'\"],\n                    'frame-ancestors': \"'none'\"\n                },\n                content_security_policy_nonce_in=['script-src'],\n                referrer_policy='no-referrer',\n                feature_policy={\n                    'geolocation': \"'none'\",\n                    'microphone': \"'none'\",\n                    'camera': \"'none'\",\n                    'payment': \"'none'\"\n                }\n            )\n            logger.info(\"âœ… HTTPS enforcement + security headers enabled (production)\")\n        else:\n            # Development: No HTTPS enforcement (allow localhost HTTP)\n            logger.info(\"âš ï¸ HTTPS enforcement disabled (development mode - HTTP only)\")\n    \n    def _setup_authentication(self):\n        \"\"\"Setup authentication for all Flask routes except /health\"\"\"\n        \n        # Exempt health check from rate limiting\n        self.limiter.exempt(lambda: request.path == '/health')\n        \n        @self.app.before_request\n        def require_auth():\n            \"\"\"Require authentication for all requests except /health\"\"\"\n            \n            # Skip auth for health check (Docker healthcheck)\n            if request.path == '/health':\n                return\n            \n            auth = request.authorization\n            \n            if not auth or not self.auth.check_credentials(auth.username, auth.password):\n                logger.warning(\n                    f\"ğŸš« Failed login attempt from {request.remote_addr} \"\n                    f\"(username: {auth.username if auth else 'none'}) \"\n                    f\"on {request.path}\"\n                )\n                return Response(\n                    'Authentication required.\\n'\n                    'Please login with valid credentials.',\n                    401,\n                    {'WWW-Authenticate': 'Basic realm=\"BotV2 Dashboard v2.0 (Secure)\"'}\n                )\n            \n            logger.debug(f\"âœ… Authenticated user: {auth.username} from {request.remote_addr}\")\n        \n        logger.info(\"âœ… Authentication middleware installed\")\n    \n    def _setup_routes(self):\n        \"\"\"Setup Flask routes with rate limiting\"\"\"\n        \n        @self.app.route('/')\n        @self.limiter.limit(\"20 per minute\")  # Higher limit for main page\n        def index():\n            \"\"\"Main dashboard page\"\"\"\n            return render_template('dashboard.html')\n        \n        @self.app.route('/api/overview')\n        @self.limiter.limit(\"20 per minute\")  # API endpoints: 20 req/min\n        def api_overview():\n            \"\"\"Portfolio overview API\"\"\"\n            return jsonify(self._get_portfolio_overview())\n        \n        @self.app.route('/api/equity')\n        @self.limiter.limit(\"20 per minute\")\n        def api_equity():\n            \"\"\"Equity curve data\"\"\"\n            return jsonify(self._get_equity_data())\n        \n        @self.app.route('/api/trades')\n        @self.limiter.limit(\"20 per minute\")\n        def api_trades():\n            \"\"\"Recent trades\"\"\"\n            limit = request.args.get('limit', 50, type=int)\n            return jsonify(self._get_trades_data(limit))\n        \n        @self.app.route('/api/strategies')\n        @self.limiter.limit(\"20 per minute\")\n        def api_strategies():\n            \"\"\"Strategy performance\"\"\"\n            return jsonify(self._get_strategies_data())\n        \n        @self.app.route('/api/risk')\n        @self.limiter.limit(\"20 per minute\")\n        def api_risk():\n            \"\"\"Risk metrics and analytics\"\"\"\n            return jsonify(self._get_risk_analytics())\n        \n        @self.app.route('/api/correlation')\n        @self.limiter.limit(\"20 per minute\")\n        def api_correlation():\n            \"\"\"Correlation heatmap data\"\"\"\n            return jsonify(self._get_correlation_matrix())\n        \n        @self.app.route('/api/attribution')\n        @self.limiter.limit(\"20 per minute\")\n        def api_attribution():\n            \"\"\"Performance attribution\"\"\"\n            return jsonify(self._get_performance_attribution())\n        \n        @self.app.route('/api/alerts')\n        @self.limiter.limit(\"20 per minute\")\n        def api_alerts():\n            \"\"\"Active alerts\"\"\"\n            return jsonify({'alerts': self.alerts})\n        \n        @self.app.route('/api/export/report')\n        @self.limiter.limit(\"5 per minute\")  # Lower limit for export (resource intensive)\n        def api_export_report():\n            \"\"\"Export PDF/Excel report\"\"\"\n            format_type = request.args.get('format', 'pdf')\n            return self._export_report(format_type)\n        \n        @self.app.route('/health')\n        # No rate limit or auth for health check\n        def health():\n            \"\"\"Health check (no authentication or rate limiting for Docker)\"\"\"\n            return jsonify({\n                'status': 'healthy',\n                'version': '2.0-secure',\n                'service': 'dashboard',\n                'uptime': self._get_uptime(),\n                'last_update': self.cache.get('last_update'),\n                'security': {\n                    'rate_limiting': True,\n                    'https_enforced': self.is_production,\n                    'authenticated': False  # Health check doesn't require auth\n                }\n            })\n    \n    def _setup_websocket_handlers(self):\n        \"\"\"Setup WebSocket event handlers (exempt from rate limiting)\"\"\"\n        \n        @self.socketio.on('connect')\n        def handle_connect():\n            \"\"\"Client connected\"\"\"\n            logger.info(f\"ğŸ”— WebSocket client connected: {request.sid} from {request.remote_addr}\")\n            emit('connected', {\n                'message': 'Connected to BotV2 Dashboard v2.0 (Secure)',\n                'version': '2.0-secure',\n                'features': ['rate_limiting', 'https_enforced' if self.is_production else 'dev_mode']\n            })\n        \n        @self.socketio.on('disconnect')\n        def handle_disconnect():\n            \"\"\"Client disconnected\"\"\"\n            logger.info(f\"âŒ WebSocket client disconnected: {request.sid}\")\n        \n        @self.socketio.on('request_update')\n        def handle_update_request(data):\n            \"\"\"Client requests data update\"\"\"\n            component = data.get('component', 'all')\n            self._emit_update(component)\n    \n    # ==================== Data Getters ====================\n    \n    def _get_portfolio_overview(self) -> Dict:\n        \"\"\"Get portfolio overview metrics\"\"\"\n        \n        if not self.portfolio_history:\n            return self._empty_portfolio()\n        \n        current = self.portfolio_history[-1]\n        initial = self.portfolio_history[0]\n        \n        # Calculate metrics\n        total_return = (current['equity'] / initial['equity'] - 1) * 100\n        \n        # Daily change\n        if len(self.portfolio_history) > 1:\n            prev = self.portfolio_history[-2]\n            daily_change = current['equity'] - prev['equity']\n            daily_change_pct = (daily_change / prev['equity']) * 100\n        else:\n            daily_change = 0\n            daily_change_pct = 0\n        \n        # Win rate\n        winning_trades = sum(1 for t in self.trades_history if t.get('pnl', 0) > 0)\n        win_rate = (winning_trades / len(self.trades_history) * 100) if self.trades_history else 0\n        \n        # Sharpe ratio\n        sharpe = self.risk_metrics.get('sharpe_ratio', 0)\n        \n        # Max drawdown\n        max_dd = self.risk_metrics.get('max_drawdown', 0)\n        \n        return {\n            'equity': current['equity'],\n            'cash': current.get('cash', 0),\n            'positions_count': len(current.get('positions', {})),\n            'total_return': total_return,\n            'daily_change': daily_change,\n            'daily_change_pct': daily_change_pct,\n            'win_rate': win_rate,\n            'total_trades': len(self.trades_history),\n            'sharpe_ratio': sharpe,\n            'max_drawdown': max_dd,\n            'timestamp': current.get('timestamp', datetime.now()).isoformat()\n        }\n    \n    def _get_equity_data(self) -> Dict:\n        \"\"\"Get equity curve data with technical indicators\"\"\"\n        \n        if not self.portfolio_history:\n            return {'timestamps': [], 'equity': [], 'sma_20': [], 'sma_50': []}\n        \n        df = pd.DataFrame(self.portfolio_history)\n        \n        # Calculate SMAs\n        df['sma_20'] = df['equity'].rolling(window=min(20, len(df))).mean()\n        df['sma_50'] = df['equity'].rolling(window=min(50, len(df))).mean()\n        \n        return {\n            'timestamps': [t.isoformat() if isinstance(t, datetime) else t \n                          for t in df['timestamp'].tolist()],\n            'equity': df['equity'].tolist(),\n            'sma_20': df['sma_20'].fillna(0).tolist(),\n            'sma_50': df['sma_50'].fillna(0).tolist(),\n            'drawdown': self._calculate_drawdown(df['equity']).tolist()\n        }\n    \n    def _get_trades_data(self, limit: int = 50) -> Dict:\n        \"\"\"Get recent trades with analytics\"\"\"\n        \n        recent_trades = self.trades_history[-limit:]\n        \n        trades_list = []\n        for trade in recent_trades:\n            trades_list.append({\n                'timestamp': trade.get('timestamp', datetime.now()).isoformat(),\n                'strategy': trade.get('strategy', 'Unknown'),\n                'symbol': trade.get('symbol', 'N/A'),\n                'action': trade.get('action', 'N/A'),\n                'size': trade.get('size', 0),\n                'entry_price': trade.get('entry_price', 0),\n                'pnl': trade.get('pnl', 0),\n                'pnl_pct': trade.get('pnl_pct', 0),\n                'confidence': trade.get('confidence', 0)\n            })\n        \n        return {\n            'trades': trades_list,\n            'summary': self._get_trades_summary()\n        }\n    \n    def _get_strategies_data(self) -> Dict:\n        \"\"\"Get strategy performance metrics\"\"\"\n        \n        strategies = []\n        \n        for name, perf in self.strategy_performance.items():\n            strategies.append({\n                'name': name,\n                'total_return': perf.get('total_return', 0) * 100,\n                'sharpe_ratio': perf.get('sharpe_ratio', 0),\n                'win_rate': perf.get('win_rate', 0) * 100,\n                'total_trades': perf.get('total_trades', 0),\n                'avg_win': perf.get('avg_win', 0),\n                'avg_loss': perf.get('avg_loss', 0),\n                'profit_factor': perf.get('profit_factor', 0),\n                'weight': perf.get('weight', 0),\n                'status': perf.get('status', 'active')\n            })\n        \n        # Sort by return\n        strategies.sort(key=lambda x: x['total_return'], reverse=True)\n        \n        return {'strategies': strategies}\n    \n    def _get_risk_analytics(self) -> Dict:\n        \"\"\"Get comprehensive risk metrics\"\"\"\n        \n        if not self.portfolio_history:\n            return self._empty_risk_metrics()\n        \n        df = pd.DataFrame(self.portfolio_history)\n        returns = df['equity'].pct_change().dropna()\n        \n        # Calculate VaR and CVaR\n        var_95 = np.percentile(returns, 5) * 100 if len(returns) > 0 else 0\n        cvar_95 = returns[returns <= np.percentile(returns, 5)].mean() * 100 if len(returns) > 0 else 0\n        \n        # Volatility\n        volatility = returns.std() * np.sqrt(252) * 100 if len(returns) > 1 else 0\n        \n        # Sortino ratio\n        downside_returns = returns[returns < 0]\n        downside_std = downside_returns.std() * np.sqrt(252) if len(downside_returns) > 1 else 0.0001\n        sortino = (returns.mean() * 252 / downside_std) if downside_std > 0 else 0\n        \n        # Calmar ratio\n        max_dd = self._calculate_max_drawdown(df['equity'])\n        calmar = (returns.mean() * 252 / abs(max_dd)) if max_dd != 0 else 0\n        \n        return {\n            'sharpe_ratio': self.risk_metrics.get('sharpe_ratio', 0),\n            'sortino_ratio': sortino,\n            'calmar_ratio': calmar,\n            'max_drawdown': max_dd * 100,\n            'current_drawdown': self._calculate_current_drawdown() * 100,\n            'volatility': volatility,\n            'var_95': var_95,\n            'cvar_95': cvar_95,\n            'beta': self.risk_metrics.get('beta', 1.0),\n            'alpha': self.risk_metrics.get('alpha', 0),\n            'information_ratio': self.risk_metrics.get('information_ratio', 0)\n        }\n    \n    def _get_correlation_matrix(self) -> Dict:\n        \"\"\"Get strategy correlation matrix\"\"\"\n        \n        if not self.strategy_performance:\n            return {'strategies': [], 'matrix': []}\n        \n        strategies = list(self.strategy_performance.keys())\n        \n        # In real implementation, calculate from returns\n        # For now, generate mock data\n        n = len(strategies)\n        correlation = np.random.rand(n, n)\n        correlation = (correlation + correlation.T) / 2  # Make symmetric\n        np.fill_diagonal(correlation, 1.0)  # Diagonal is 1\n        \n        return {\n            'strategies': strategies,\n            'matrix': correlation.tolist()\n        }\n    \n    def _get_performance_attribution(self) -> Dict:\n        \"\"\"Get performance attribution by strategy\"\"\"\n        \n        attribution = []\n        \n        total_pnl = sum(s.get('total_pnl', 0) for s in self.strategy_performance.values())\n        \n        for name, perf in self.strategy_performance.items():\n            strategy_pnl = perf.get('total_pnl', 0)\n            contribution = (strategy_pnl / total_pnl * 100) if total_pnl != 0 else 0\n            \n            attribution.append({\n                'strategy': name,\n                'pnl': strategy_pnl,\n                'contribution_pct': contribution\n            })\n        \n        # Sort by contribution\n        attribution.sort(key=lambda x: abs(x['contribution_pct']), reverse=True)\n        \n        return {'attribution': attribution}\n    \n    # ==================== Helper Methods ====================\n    \n    def _calculate_drawdown(self, equity_series) -> pd.Series:\n        \"\"\"Calculate drawdown series\"\"\"\n        cummax = equity_series.expanding().max()\n        drawdown = (equity_series - cummax) / cummax\n        return drawdown\n    \n    def _calculate_max_drawdown(self, equity_series) -> float:\n        \"\"\"Calculate maximum drawdown\"\"\"\n        drawdown = self._calculate_drawdown(equity_series)\n        return drawdown.min()\n    \n    def _calculate_current_drawdown(self) -> float:\n        \"\"\"Calculate current drawdown\"\"\"\n        if not self.portfolio_history:\n            return 0.0\n        \n        df = pd.DataFrame(self.portfolio_history)\n        current_equity = df['equity'].iloc[-1]\n        peak = df['equity'].max()\n        \n        return (current_equity - peak) / peak if peak > 0 else 0.0\n    \n    def _get_trades_summary(self) -> Dict:\n        \"\"\"Get trades summary statistics\"\"\"\n        \n        if not self.trades_history:\n            return {\n                'total_trades': 0,\n                'winning_trades': 0,\n                'losing_trades': 0,\n                'win_rate': 0,\n                'avg_win': 0,\n                'avg_loss': 0,\n                'profit_factor': 0,\n                'total_pnl': 0\n            }\n        \n        winning = [t for t in self.trades_history if t.get('pnl', 0) > 0]\n        losing = [t for t in self.trades_history if t.get('pnl', 0) < 0]\n        \n        total_wins = sum(t.get('pnl', 0) for t in winning)\n        total_losses = abs(sum(t.get('pnl', 0) for t in losing))\n        \n        return {\n            'total_trades': len(self.trades_history),\n            'winning_trades': len(winning),\n            'losing_trades': len(losing),\n            'win_rate': len(winning) / len(self.trades_history) * 100,\n            'avg_win': total_wins / len(winning) if winning else 0,\n            'avg_loss': total_losses / len(losing) if losing else 0,\n            'profit_factor': total_wins / total_losses if total_losses > 0 else 0,\n            'total_pnl': sum(t.get('pnl', 0) for t in self.trades_history)\n        }\n    \n    def _empty_portfolio(self) -> Dict:\n        \"\"\"Return empty portfolio structure\"\"\"\n        return {\n            'equity': 0,\n            'cash': 0,\n            'positions_count': 0,\n            'total_return': 0,\n            'daily_change': 0,\n            'daily_change_pct': 0,\n            'win_rate': 0,\n            'total_trades': 0,\n            'sharpe_ratio': 0,\n            'max_drawdown': 0,\n            'timestamp': datetime.now().isoformat()\n        }\n    \n    def _empty_risk_metrics(self) -> Dict:\n        \"\"\"Return empty risk metrics\"\"\"\n        return {\n            'sharpe_ratio': 0,\n            'sortino_ratio': 0,\n            'calmar_ratio': 0,\n            'max_drawdown': 0,\n            'current_drawdown': 0,\n            'volatility': 0,\n            'var_95': 0,\n            'cvar_95': 0,\n            'beta': 1.0,\n            'alpha': 0,\n            'information_ratio': 0\n        }\n    \n    def _get_uptime(self) -> str:\n        \"\"\"Get system uptime\"\"\"\n        # Placeholder - implement actual uptime tracking\n        return \"Running\"\n    \n    def _export_report(self, format_type: str):\n        \"\"\"Export performance report\"\"\"\n        # Placeholder - implement actual report generation\n        return jsonify({'status': 'not_implemented', 'format': format_type})\n    \n    def _emit_update(self, component: str = 'all'):\n        \"\"\"Emit WebSocket update to clients\"\"\"\n        \n        updates = {}\n        \n        if component in ['all', 'overview']:\n            updates['overview'] = self._get_portfolio_overview()\n        \n        if component in ['all', 'equity']:\n            updates['equity'] = self._get_equity_data()\n        \n        if component in ['all', 'strategies']:\n            updates['strategies'] = self._get_strategies_data()\n        \n        if component in ['all', 'risk']:\n            updates['risk'] = self._get_risk_analytics()\n        \n        self.socketio.emit('update', updates)\n    \n    # ==================== Public API ====================\n    \n    def update_data(self, portfolio: Dict, trades: List, strategies: Dict, risk: Dict):\n        \"\"\"\n        Update dashboard data from trading system\n        \n        Args:\n            portfolio: Current portfolio state\n            trades: Recent trades list\n            strategies: Strategy performance dict\n            risk: Risk metrics dict\n        \"\"\"\n        \n        # Add to history\n        self.portfolio_history.append({\n            'timestamp': datetime.now(),\n            'equity': portfolio.get('equity', 0),\n            'cash': portfolio.get('cash', 0),\n            'positions': portfolio.get('positions', {})\n        })\n        \n        # Keep last 10000 points (adjustable)\n        if len(self.portfolio_history) > 10000:\n            self.portfolio_history = self.portfolio_history[-10000:]\n        \n        self.trades_history = trades\n        self.strategy_performance = strategies\n        self.risk_metrics = risk\n        \n        # Update cache\n        self.cache['last_update'] = datetime.now().isoformat()\n        \n        # Emit WebSocket update\n        self._emit_update('all')\n        \n        logger.debug(\"Dashboard data updated via WebSocket\")\n    \n    def add_alert(self, level: str, message: str, category: str = 'general'):\n        \"\"\"\n        Add alert to dashboard\n        \n        Args:\n            level: Alert level (info, warning, danger)\n            message: Alert message\n            category: Alert category\n        \"\"\"\n        \n        alert = {\n            'id': len(self.alerts),\n            'timestamp': datetime.now().isoformat(),\n            'level': level,\n            'message': message,\n            'category': category\n        }\n        \n        self.alerts.append(alert)\n        \n        # Keep last 100 alerts\n        if len(self.alerts) > 100:\n            self.alerts = self.alerts[-100:]\n        \n        # Emit alert via WebSocket\n        self.socketio.emit('alert', alert)\n        \n        logger.info(f\"Alert added: [{level}] {message}\")\n    \n    def run(self):\n        \"\"\"Start dashboard server\"\"\"\n        \n        logger.info(\"=\"*70)\n        logger.info(\"ğŸš€ Starting BotV2 Professional Dashboard v2.0 (Secure)\")\n        logger.info(f\"ğŸŒ URL: http{'s' if self.is_production else ''}://{self.host}:{self.port}\")\n        logger.info(f\"ğŸ”’ Authentication: ENABLED (user: {self.auth.username})\")\n        logger.info(\"ğŸ”‘ Password: Set via DASHBOARD_PASSWORD env var\")\n        logger.info(f\"âš¡ Rate Limiting: ENABLED (10 req/min global, 20 req/min API)\")\n        logger.info(f\"ğŸ” HTTPS: {'ENFORCED' if self.is_production else 'DISABLED (dev)'}\")\n        logger.info(\"âœ¨ Features: WebSocket, Real-time, Advanced Analytics, Enterprise Security\")\n        logger.info(f\"ğŸ“Š Health Check: http://{self.host}:{self.port}/health\")\n        logger.info(\"=\"*70)\n        \n        self.socketio.run(\n            self.app,\n            host=self.host,\n            port=self.port,\n            debug=self.debug,\n            use_reloader=False,\n            allow_unsafe_werkzeug=True\n        )\n\n\n# Alias for backward compatibility\nTradingDashboard = ProfessionalDashboard\n\n\nif __name__ == \"__main__\":\n    from src.config.config_manager import ConfigManager\n    \n    config = ConfigManager()\n    dashboard = ProfessionalDashboard(config)\n    dashboard.run()\n